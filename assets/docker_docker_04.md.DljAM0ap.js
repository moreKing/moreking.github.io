import{_ as a,c as e,ai as i,o as n}from"./chunks/framework.DcWFUpHS.js";const k=JSON.parse('{"title":"容器操作","description":"","frontmatter":{},"headers":[],"relativePath":"docker/docker/04.md","filePath":"docker/docker/04.md","lastUpdated":1737611111000}'),t={name:"docker/docker/04.md"};function r(l,s,p,o,d,c){return n(),e("div",null,s[0]||(s[0]=[i(`<h1 id="容器操作" tabindex="-1">容器操作 <a class="header-anchor" href="#容器操作" aria-label="Permalink to &quot;容器操作&quot;">​</a></h1><h3 id="_1-docker-run" tabindex="-1">1 docker run <a class="header-anchor" href="#_1-docker-run" aria-label="Permalink to &quot;1 docker run&quot;">​</a></h3><p>由于这个命令比较复杂，下面将以具体的步骤进行演示，首先我们要知道<code>docker run</code>运行的流程</p><p>用户执行<code>docker run</code>来启动容器的时候，docker服务端会先检查本地有没有run的镜像，如果有，那么docker直接使用这个镜像</p><p>格式：docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</p><p><strong>OPTIONS说明（常用）</strong>：单词用两个-- 简写用一个-</p><ul><li>--name=&quot;容器新名字&quot; 为容器指定一个名称；</li><li>-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</li><li>-i：以交互模式运行容器，通常与 -t 同时使用；</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；也即启动交互式容器(前台有伪终端，等待交互)；</li><li>-P: 随机端口映射，大写P，一般不使用</li><li>-p: 指定端口映射，小写p ，常用</li><li><strong>-v</strong>:挂载容器卷，做数据持久化，默认是读写权限<code>rw</code>，如果只读只需要在结尾加上 <code>:ro</code>即可</li></ul><p>​ <strong>-v /宿主机绝对路径目录:/容器内目录 [:ro]</strong></p><ul><li><p><strong>--volumes-from</strong> 父类：继承其他容器挂载容器卷，父容器即便被删除，子容器的挂载不会有变化</p></li><li><p><strong>--privileged=true</strong>：如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用--privileged=true命令，扩大容器的权限解决挂载目录没有权限的问题，使用该参数，<strong>container内的root拥有真正的root权限</strong>，否则，container内的root只是外部的一个普通用户权限。</p></li></ul><p><strong>COMMAND：</strong></p><p>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。 要退出终端，直接输入 exit，保留运行容器需要使用ctrl+p+q</p><h3 id="_2-docker-inspect" tabindex="-1">2 docker inspect <a class="header-anchor" href="#_2-docker-inspect" aria-label="Permalink to &quot;2 docker inspect&quot;">​</a></h3><p>docker inspect 容器ID 查看容器详细信息,查看容器内部细节</p><h3 id="_3-docker-logs" tabindex="-1">3 docker logs <a class="header-anchor" href="#_3-docker-logs" aria-label="Permalink to &quot;3 docker logs&quot;">​</a></h3><p>查看容器日志：docker logs 容器ID</p><h3 id="_4-docker-cp" tabindex="-1">4 docker cp <a class="header-anchor" href="#_4-docker-cp" aria-label="Permalink to &quot;4 docker cp&quot;">​</a></h3><p>容器与主机文件拷贝 ：docker cp 容器ID:容器内路径 目的主机路径</p><p>注意有两种情况</p><ol><li>主机上文件拷贝到容器：docker cp 主机文件路径 容器ID:容器内路径</li><li>容器内文件拷贝到主机：docker cp 容器ID:容器内路径 目的主机路径</li></ol><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#将主机上bin文件拷贝到容器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  pkg</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /root/go/bin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 918822e6486b:/tmp/test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 容器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  bin</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_5-docker-exec" tabindex="-1">5 docker exec <a class="header-anchor" href="#_5-docker-exec" aria-label="Permalink to &quot;5 docker exec&quot;">​</a></h3><p>进入容器命令终端 :docker exec -it 容器ID bashShell</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># docker exec -it 327dcdc96475 sh</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # cd /tmp/test/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/tmp/test</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # ls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  bin</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_6-docker-attach" tabindex="-1">6 docker attach <a class="header-anchor" href="#_6-docker-attach" aria-label="Permalink to &quot;6 docker attach&quot;">​</a></h3><p>进入容器启动命令终端 :docker attach 容器ID</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> attach</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 327</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /tmp/test/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1.txt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  bin</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>attach 直接进入容器启动命令的终端，不会启动新的进程，用exit退出，会导致容器的停止。</p><p>exec 是在容器中打开新的终端，并且启动新的进程，用exit退出，不会导致容器的停止。</p><p>两者使用快捷键：<strong>ctrl+p+q</strong> 退出都不会停止容器</p></blockquote><h3 id="_7-docker-top" tabindex="-1">7 docker top <a class="header-anchor" href="#_7-docker-top" aria-label="Permalink to &quot;7 docker top&quot;">​</a></h3><p>查看容器内运行的进程 : docker top 容器ID</p><h3 id="_8-dockre-rm" tabindex="-1">8 dockre rm <a class="header-anchor" href="#_8-dockre-rm" aria-label="Permalink to &quot;8 dockre rm&quot;">​</a></h3><p><strong>语法</strong>: docker rm [OPTIONS] CONTAINER [CONTAINER...]</p><p>OPTIONS说明：</p><table tabindex="0"><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><strong>-f</strong></td><td>通过 SIGKILL 信号强制删除一个运行中的容器。</td></tr><tr><td><strong>-l</strong></td><td>移除容器间的网络连接，而非容器本身。</td></tr><tr><td><strong>-v</strong></td><td>删除与容器关联的卷</td></tr></tbody></table><p>删除所有容器：<code>docker rm -f $(docker ps -a -q)</code></p><p>删除所有未运行的容器: <code>docker container prune</code> / <code>docker rm $(docker ps -a -q)</code></p><p>删除未启动成功：<code>docker rm $(docker ps -qf status=created)</code></p><p>删除退出状态: <code>docker rm $(docker ps -qf status=exited)</code></p><h3 id="_9-docker-kill" tabindex="-1">9 docker kill <a class="header-anchor" href="#_9-docker-kill" aria-label="Permalink to &quot;9 docker kill&quot;">​</a></h3><p>停止所有运行的容器 : <code>docker kill $(docker ps -a -q)</code></p>`,39)]))}const b=a(t,[["render",r]]);export{k as __pageData,b as default};
