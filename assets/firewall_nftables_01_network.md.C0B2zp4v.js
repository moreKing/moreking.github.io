import{_ as n,c as d,ai as a,G as r,j as e,a as l,B as i,o as s}from"./chunks/framework.DcWFUpHS.js";const P=JSON.parse('{"title":"网络前置知识","description":"","frontmatter":{},"headers":[],"relativePath":"firewall/nftables/01/network.md","filePath":"firewall/nftables/01/network.md","lastUpdated":1737611111000}'),p={name:"firewall/nftables/01/network.md"};function c(g,t,_,u,m,f){const o=i("MyImg");return s(),d("div",null,[t[0]||(t[0]=a('<h1 id="网络前置知识" tabindex="-1">网络前置知识 <a class="header-anchor" href="#网络前置知识" aria-label="Permalink to &quot;网络前置知识&quot;">​</a></h1><p>在学习防火墙之前，我们需要具备一定的网络基础知识，一般新入门的系统管理员可能不够了解，所以为了后面的内容更好的理解，在此处重新讲解一下数据包在网络中是怎么传输的，有此知识储备的请跳过本章节</p><p>完整的网络知识，强烈推荐B站UP主 <a href="https://www.bilibili.com/video/BV1c4411d7CQ/?spm_id_from=333.999.0.0&amp;vd_source=71680d904d5818020a833902208b8533" target="_blank" rel="noreferrer">湖科大教书匠视频</a>，我本人也是通过他的视频进行基础知识的学习</p><h3 id="_1-osi-七层模型-和-tcp-ip-四层模型" tabindex="-1">1. OSI 七层模型 和 TCP/IP 四层模型 <a class="header-anchor" href="#_1-osi-七层模型-和-tcp-ip-四层模型" aria-label="Permalink to &quot;1. OSI 七层模型 和 TCP/IP 四层模型&quot;">​</a></h3><p>OSI七层模型是理论模型，一般用于理论研究，他的分层有些冗余，实际应用，选择 TCP/IP 的四层 模型 。 而且 OSI 自身也有缺陷，大多数人都认为 OSI 模型的层次数量与内容可能是最佳的选择，其实 并非如此， 其中会话层和表示层几乎是空的 ，而数据链路层和网络层包含内容太多，有很多的子层插入每个子层都有不同的功能。</p><p>而我们本次目的主要就是学习 TCP/IP 中的网络层</p><p>七层模型中各个层的功能：</p><table tabindex="0"><thead><tr><th>分层名称</th><th>功能</th></tr></thead><tbody><tr><td>应用层</td><td>为应用程序提供服务</td></tr><tr><td>表示层</td><td>设备固有数据格式和网络格式的转化</td></tr><tr><td>会话层</td><td>通信管理，负责建立和断开会话</td></tr><tr><td>传输层</td><td>管理端对端的数据传输连接</td></tr><tr><td>网络层</td><td>地址管理和路由选择</td></tr><tr><td>数据链路层</td><td>链路管理和识别数据帧</td></tr><tr><td>物理层</td><td>物理设备传输比特流</td></tr></tbody></table>',8)),r(o,{url:"/firewall/nftables/01-4.png"}),t[1]||(t[1]=a('<p>从图中我们可以看出，在事实标准的TCP/IP 四层模型中，由于会话层和表示层几乎是空的 ，应用层对应了一个合并的OSI的5-7层，，其他的层级基本是保持不变</p><div class="tip custom-block"><p class="custom-block-title">提示</p><p><strong>在实际的问题排错中，我们按照TCP/IP模型进行排错即可</strong></p></div><h3 id="_2-数据包在网络中的传输过程" tabindex="-1">2. 数据包在网络中的传输过程 <a class="header-anchor" href="#_2-数据包在网络中的传输过程" aria-label="Permalink to &quot;2. 数据包在网络中的传输过程&quot;">​</a></h3><p>要说明的是，首先我们需要有一个基本的概念，就是你需要知道电脑上有 mac地址、IP地址、子网掩码、网关、路由 这几个概念，本章不涉及更深的内容，仅说明一个数据包如何通过这几个东西进行传播</p><h4 id="_2-1-从系统内看数据包是如何产生的" tabindex="-1">2.1 从系统内看数据包是如何产生的 <a class="header-anchor" href="#_2-1-从系统内看数据包是如何产生的" aria-label="Permalink to &quot;2.1 从系统内看数据包是如何产生的&quot;">​</a></h4><p>注意，我们后面接触的所有知识，都是基于 <strong>TCP/IP 模型</strong> 的，OSI模型只作为理论标准， <strong>TCP/IP 模型</strong> 是事实标准，两者区别还是比较大的</p><p><strong>1.</strong> 应用层发送一个消息，比如： <code>你好</code> 这两个字，应用本身会对这个数据做一些处理，比如<code>加密</code>、<code>格式化</code>等处理完成后根据要发送的协议进行打包，转交下一层进行处理</p><p><strong>2.</strong> 传输层提供两个协议： <code>TCP</code> 、<code>UDP</code> 协议，接受消息后，根据用户指定的不同的协议族来进行不同的传输，并在首部将这些信息进行打包添加</p><p><strong>3.</strong> 网络层在首部添加IP信息</p><p><strong>4.</strong> 链路层首部添加包含mac地址信息，尾部包围住</p><p><strong>5.</strong> 物理层发送0101 的字节码</p>',11)),r(o,{url:"/firewall/nftables/01-5.png"}),t[2]||(t[2]=e("p",null,[e("br"),e("br")],-1)),t[3]||(t[3]=e("h4",{id:"_2-2-数据在网络中是如何传输的",tabindex:"-1"},[e("div",{style:{color:"red"}},"2.2 数据在网络中是如何传输的"),l(),e("a",{class:"header-anchor",href:"#_2-2-数据在网络中是如何传输的","aria-label":'Permalink to "<div style="color:red">2.2 数据在网络中是如何传输的</div>"'},"​")],-1)),t[4]||(t[4]=e("p",null,"看完数据在系统内部是如何产生的以后，我们再来看看数据包再网络中是如何传输的",-1)),r(o,{url:"/firewall/nftables/01-6.svg"}),t[5]||(t[5]=a('<p>对着上图我们进行如下说明</p><p>如果无mac地址缓存，发送arp报获取mac地址填充并发送这个过程不在里面重复赘述了</p><p><strong>数据传输过程</strong>：</p><ol><li>数据在填充mac目的地址时，会对本地ip以及掩码计算所在的网段，对目的IP进行判断，是否跟本地IP一个地址段</li><li>是一个地址段 目的mac直接写目标地址的mac</li><li>不在一个地址段，填充mac地址是会填写网关的mac地址</li><li>网关收到数据进行IP地址判断，根据路由表判断从哪个网卡发出以及下跳的mac地址，并将数据包的源mac地址改成网关自己的mac地址</li><li>经历多个网关原理一致</li><li>到达目的地址所在的路由器，判断出接口在一个段，所以mac地址直接写目的mac，源mac地址依然修改成发出的网卡的</li><li>数据回包流程相反</li></ol><p>由此，我们可以已经具备了网络中的 mac、ip、掩码、网关、路由的概念以及基本作用，还有更多的功能此处暂时不再详细赘述</p><h3 id="_3-tcp连接" tabindex="-1">3. tcp连接 <a class="header-anchor" href="#_3-tcp连接" aria-label="Permalink to &quot;3. tcp连接&quot;">​</a></h3>',6)),r(o,{url:"/firewall/nftables/01-7.png"}),t[6]||(t[6]=a("<p><code>Sequence Number(seq)</code>：<code>32bit</code>，表示<code>tcp</code>包的序列号，根据<code>seq</code>来确认是否有数据包丢失。</p><p><code>Acknowledgment Number(ack)</code>：<code>32bit</code>，表示<code>tcp</code>包的确认号。表示已经收到对方多少数据。</p><p>对于<code>seq</code>来说，可以理解为，我已经<strong>发出了</strong>多少数据；</p><p>对于<code>ack</code>来说，可以理解为，我已经<strong>接收了</strong>多少数据。</p><p>这是在此次发包的时候，<strong>对当前状态的总结</strong>，<strong>不包括本次发送的包</strong>，因为此次发送的动作并没有完成</p><p>发出带有<code>SYN</code>或<code>FIN</code>标志的报文，<code>seq</code>需要+1；只带有<code>ACK</code>标志的报文，<code>seq</code>不需要+1。</p><p><strong>Flags值说明：</strong></p><ul><li><strong>FIN</strong>: &quot;finished&quot;简写。表示发送者以及发送完数据。通常用在发送者发送完数据的最后一个包中。</li><li><strong>SYN</strong>: &quot;Synchronisation&quot;简写。表示三次握手建立连接的第一步，在建立连接时发送者发送的第一个包中设置flag值为SYN。</li><li><strong>RST</strong>: &quot;reset&quot;简写。重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者发送包发送到一个不是期望的目的主机时，接收端发送reset 重置连接标志的包。</li><li><strong>PSH</strong>: &quot;push&quot;简写。通知接收端处理接收的报文，而不是将报文缓存到buffer中。</li><li><strong>ACK</strong>: &quot;Acknowledgment&quot;简写。表示包已经被成功接收。</li><li><strong>URG</strong>: &quot;urgent&quot;简写。通知接收端处理在处理其他包前优先处理接收到的紧急报文（urgent packets）。详见RFC6093。</li><li><em>ECE</em>: &quot;ECN-Echo&quot;简写。ECN表示Explicit Congestion Notification。表示TCP peer有ECN能力。详见RFC3168。【新tcp新增】</li><li><em>CWR</em>: &quot;Congestion Window Reduced&quot;简写。发送者在接收到一个带有ECE flag包时，将会使用CWR flag。 详见RFC3168。【新tcp新增】</li><li><em>NS</em>: &quot;nonce sum&quot;简写。该标签用来保护不受发送者发送的突发的恶意隐藏报文的侵害。详见 RFC 3540。【新tcp新增】</li></ul>",8)),r(o,{url:"/firewall/nftables/01-8.png"}),t[7]||(t[7]=e("h4",{id:"_3-1-三次握手",tabindex:"-1"},[l("3.1 三次握手 "),e("a",{class:"header-anchor",href:"#_3-1-三次握手","aria-label":'Permalink to "3.1 三次握手"'},"​")],-1)),r(o,{url:"/firewall/nftables/network-01.jpg"}),t[8]||(t[8]=e("h4",{id:"_3-2-四次挥手",tabindex:"-1"},[l("3.2 四次挥手 "),e("a",{class:"header-anchor",href:"#_3-2-四次挥手","aria-label":'Permalink to "3.2 四次挥手"'},"​")],-1)),r(o,{url:"/firewall/nftables/network-02.png"}),t[9]||(t[9]=e("h4",{id:"_3-3-抓包分析",tabindex:"-1"},[l("3.3 抓包分析 "),e("a",{class:"header-anchor",href:"#_3-3-抓包分析","aria-label":'Permalink to "3.3 抓包分析"'},"​")],-1)),r(o,{url:"/firewall/nftables/network-03.png"})])}const h=n(p,[["render",c]]);export{P as __pageData,h as default};
